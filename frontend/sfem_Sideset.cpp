#include "sfem_Sideset.hpp"

// C includes
#include "matrixio_array.h"
#include "utils.h"

#include "sfem_defs.h"
#include "sfem_logger.h"
#include "sfem_mesh.h"

// Mesh
#include "adj_table.h"
#include "hex8_fff.h"
#include "hex8_jacobian.h"
#include "sfem_hex8_mesh_graph.h"
#include "sshex8.h"
#include "sshex8_mesh.h"

// C++ includes
#include "sfem_FunctionSpace.hpp"
#include "sfem_SemiStructuredMesh.hpp"
#include "sfem_Tracer.hpp"
#include "sfem_glob.hpp"

#include <stddef.h>
#include <sys/stat.h>

#include <cstddef>
#include <fstream>
#include <iostream>
#include <list>
#include <vector>

namespace sfem {

    class Sideset::Impl final {
    public:
        std::shared_ptr<Communicator>          comm;
        std::shared_ptr<Buffer<element_idx_t>> parent;
        std::shared_ptr<Buffer<int16_t>>       lfi;
    };

    Sideset::Sideset(const std::shared_ptr<Communicator>          &comm,
                     const std::shared_ptr<Buffer<element_idx_t>> &parent,
                     const std::shared_ptr<Buffer<int16_t>>       &lfi)
        : impl_(std::make_unique<Impl>()) {
        impl_->comm   = comm;
        impl_->parent = parent;
        impl_->lfi    = lfi;
    }

    Sideset::Sideset() : impl_(std::make_unique<Impl>()) {}
    Sideset::~Sideset() = default;

    ptrdiff_t Sideset::size() const { return impl_->parent->size(); }

    std::shared_ptr<Communicator> Sideset::comm() const { return impl_->comm; }

    std::shared_ptr<Sideset> Sideset::create(const std::shared_ptr<Communicator>          &comm,
                                             const std::shared_ptr<Buffer<element_idx_t>> &parent,
                                             const std::shared_ptr<Buffer<int16_t>>       &lfi) {
        return std::make_shared<Sideset>(comm, parent, lfi);
    }

    std::shared_ptr<Sideset> Sideset::create_from_file(const std::shared_ptr<Communicator> &comm, const char *path) {
        auto ret = std::make_shared<Sideset>();
        if (ret->read(comm, path) != SFEM_SUCCESS) return nullptr;
        return ret;
    }

    int Sideset::write(const char *path) const {
        std::string sideset_path = path;
        sfem::create_directory(sideset_path.c_str());

        std::string parent_path = sideset_path + "/parent.raw";
        array_write(impl_->comm->get(),
                    parent_path.c_str(),
                    SFEM_MPI_ELEMENT_IDX_T,
                    impl_->parent->data(),
                    impl_->parent->size(),
                    impl_->parent->size());

        std::string lfi_path = sideset_path + "/lfi.int16.raw";
        array_write(impl_->comm->get(), lfi_path.c_str(), MPI_SHORT, impl_->lfi->data(), impl_->lfi->size(), impl_->lfi->size());

        std::ofstream os(sideset_path + "/meta.yaml");

        if (os.good()) {
            os << "# Automatically generated by sfem_Sideset.cpp\n";
            os << "parent: parent.raw\n";
            os << "lfi: lfi.int16.raw\n";
            os << "rpath: true\n";
        } else {
            SFEM_ERROR("Unable to open sideset meta.yaml file\n");
            return SFEM_FAILURE;
        }

        os.close();

        return SFEM_SUCCESS;
    }

    std::shared_ptr<Sideset> Sideset::create_from_selector(
            const std::shared_ptr<Mesh>                                         &mesh,
            const std::function<bool(const geom_t, const geom_t, const geom_t)> &selector) {
        SFEM_TRACE_SCOPE("Sideset::create_from_selector");

        const ptrdiff_t nelements = mesh->n_elements();
        const ptrdiff_t nnodes    = mesh->n_nodes();
        const int       dim       = mesh->spatial_dimension();

        auto elements = mesh->elements()->data();
        auto points   = mesh->points()->data();

        enum ElemType element_type = mesh->element_type();

        const enum ElemType st   = side_type(element_type);
        const int           nnxs = elem_num_nodes(st);
        const int           ns   = elem_num_sides(element_type);

        std::vector<int> local_side_table(ns * nnxs);
        fill_local_side_table(mesh->element_type(), local_side_table.data());

        std::list<element_idx_t> parent_list;
        std::list<int16_t>       lfi_list;

        for (ptrdiff_t e = 0; e < nelements; e++) {
            for (int s = 0; s < ns; s++) {
                // Barycenter of face
                double p[3] = {0, 0, 0};

                for (int ln = 0; ln < nnxs; ln++) {
                    const idx_t node = elements[local_side_table[s * nnxs + ln]][e];

                    for (int d = 0; d < dim; d++) {
                        p[d] += points[d][node];
                    }
                }

                for (int d = 0; d < dim; d++) {
                    p[d] /= nnxs;
                }

                if (selector(p[0], p[1], p[2])) {
                    parent_list.push_back(e);
                    lfi_list.push_back(s);
                }
            }
        }

        const ptrdiff_t nparents = parent_list.size();
        auto            parent   = create_host_buffer<element_idx_t>(nparents);
        auto            lfi      = create_host_buffer<int16_t>(nparents);

        {
            ptrdiff_t idx = 0;
            for (auto p : parent_list) {
                parent->data()[idx++] = p;
            }
        }

        {
            ptrdiff_t idx = 0;
            for (auto l : lfi_list) {
                lfi->data()[idx++] = l;
            }
        }

        return std::make_shared<Sideset>(mesh->comm(), parent, lfi);
    }

    int Sideset::read(const std::shared_ptr<Communicator> &comm, const char *folder) {
        SFEM_TRACE_SCOPE("Sideset::read");

        impl_->comm = comm;

        std::string    folder_ = folder;
        ptrdiff_t      nlocal{0}, nglobal{0}, ncheck{0};
        element_idx_t *parent{nullptr};
        int16_t       *lfi{nullptr};

        if (array_create_from_file(comm->get(),
                                   (folder_ + "/parent.raw").c_str(),
                                   SFEM_MPI_ELEMENT_IDX_T,
                                   (void **)&parent,
                                   &nlocal,
                                   &nglobal) ||
            array_create_from_file(
                    comm->get(), (folder_ + "/lfi.int16.raw").c_str(), MPI_SHORT, (void **)&lfi, &ncheck, &nglobal)) {
            return SFEM_FAILURE;
        }

        impl_->parent = sfem::manage_host_buffer(nlocal, parent);
        impl_->lfi    = sfem::manage_host_buffer(nlocal, lfi);

        if (ncheck != nlocal) {
            SFEM_ERROR("Inconsistent array sizes in sideset at %s\n", folder);
            return SFEM_FAILURE;
        }

        return SFEM_SUCCESS;
    }

    std::shared_ptr<Buffer<element_idx_t>> Sideset::parent() { return impl_->parent; }
    std::shared_ptr<Buffer<int16_t>>       Sideset::lfi() { return impl_->lfi; }

    std::shared_ptr<Buffer<idx_t>> create_nodeset_from_sideset(const std::shared_ptr<FunctionSpace> &space,
                                                               const std::shared_ptr<Sideset>       &sideset) {
        ptrdiff_t n_nodes{0};
        idx_t    *nodes{nullptr};
        if (space->has_semi_structured_mesh()) {
            auto &&ss = space->semi_structured_mesh();
            SFEM_TRACE_SCOPE("sshex8_extract_nodeset_from_sideset");
            if (sshex8_extract_nodeset_from_sideset(ss.level(),
                                                    ss.element_data(),
                                                    sideset->parent()->size(),
                                                    sideset->parent()->data(),
                                                    sideset->lfi()->data(),
                                                    &n_nodes,
                                                    &nodes) != SFEM_SUCCESS) {
                SFEM_ERROR("Unable to extract nodeset from sideset!\n");
            }
        } else {
            if (extract_nodeset_from_sideset(space->element_type(),
                                             space->mesh_ptr()->elements()->data(),
                                             sideset->parent()->size(),
                                             sideset->parent()->data(),
                                             sideset->lfi()->data(),
                                             &n_nodes,
                                             &nodes) != SFEM_SUCCESS) {
                SFEM_ERROR("Unable to extract nodeset from sideset!\n");
            }
        }

        return sfem::manage_host_buffer(n_nodes, nodes);
    }

    std::pair<enum ElemType, std::shared_ptr<Buffer<idx_t *>>> create_surface_from_sideset(
            const std::shared_ptr<FunctionSpace> &space,
            const std::shared_ptr<Sideset>       &sideset) {
        if (space->has_semi_structured_mesh()) {
            auto &&ssmesh = space->semi_structured_mesh();
            auto   ss_sides =
                    sfem::create_host_buffer<idx_t>((ssmesh.level() + 1) * (ssmesh.level() + 1), sideset->parent()->size());

            if (sshex8_extract_surface_from_sideset(ssmesh.level(),
                                                    ssmesh.element_data(),
                                                    sideset->parent()->size(),
                                                    sideset->parent()->data(),
                                                    sideset->lfi()->data(),
                                                    ss_sides->data()) != SFEM_SUCCESS) {
                SFEM_ERROR("Unable to extract surface from sideset!\n");
            }

            idx_t           *idx          = nullptr;
            ptrdiff_t        n_contiguous = SFEM_PTRDIFF_INVALID;
            std::vector<int> levels(sshex8_hierarchical_n_levels(ssmesh.level()));

            // FiXME harcoded for sshex8
            sshex8_hierarchical_mesh_levels(ssmesh.level(), levels.size(), levels.data());

            const int nnxs    = 4;
            const int nexs    = ssmesh.level() * ssmesh.level();
            auto      surface = sfem::create_host_buffer<idx_t>(nnxs, sideset->parent()->size() * nexs);

            ssquad4_to_standard_quad4_mesh(ssmesh.level(), sideset->parent()->size(), ss_sides->data(), surface->data());
            return {QUADSHELL4, surface};
        } else {
            auto st   = shell_type(side_type(space->element_type()));
            int  nnxs = elem_num_nodes(st);

            auto surface = sfem::create_host_buffer<idx_t>(nnxs, sideset->parent()->size());
            auto mesh    = space->mesh_ptr();
            if (extract_surface_from_sideset(space->element_type(),
                                             mesh->elements()->data(),
                                             sideset->parent()->size(),
                                             sideset->parent()->data(),
                                             sideset->lfi()->data(),
                                             surface->data()) != SFEM_SUCCESS) {
                SFEM_ERROR("Unable to create surface from sideset!");
            }
            return {st, surface};
        }
    }
}  // namespace sfem
