#include "sfem_Sideset.hpp"

// C includes
#include "matrixio_array.h"
#include "utils.h"

#include "sfem_defs.h"
#include "sfem_logger.h"
#include "sfem_mesh.h"

// Mesh
#include "adj_table.h"
#include "hex8_fff.h"
#include "hex8_jacobian.h"
#include "sfem_hex8_mesh_graph.h"
#include "sshex8.h"
#include "sshex8_mesh.h"

// C++ includes
#include "sfem_FunctionSpace.hpp"
#include "sfem_SemiStructuredMesh.hpp"
#include "sfem_Tracer.hpp"
#include "sfem_glob.hpp"

#include <stddef.h>
#include <sys/stat.h>

#include <cstddef>
#include <fstream>
#include <iostream>
#include <list>
#include <vector>

namespace sfem {

    class Sideset::Impl final {
    public:
        std::shared_ptr<Communicator>          comm;
        std::shared_ptr<Buffer<element_idx_t>> parent;
        std::shared_ptr<Buffer<int16_t>>       lfi;
        uint16_t                               block_id{0};
    };

    Sideset::Sideset(const std::shared_ptr<Communicator>          &comm,
                     const std::shared_ptr<Buffer<element_idx_t>> &parent,
                     const std::shared_ptr<Buffer<int16_t>>       &lfi,
                     uint16_t                                      block_id)
        : impl_(std::make_unique<Impl>()) {
        impl_->comm     = comm;
        impl_->parent   = parent;
        impl_->lfi      = lfi;
        impl_->block_id = block_id;
    }

    Sideset::Sideset() : impl_(std::make_unique<Impl>()) {}
    Sideset::~Sideset() = default;

    ptrdiff_t Sideset::size() const { return impl_->parent->size(); }

    std::shared_ptr<Communicator> Sideset::comm() const { return impl_->comm; }

    std::shared_ptr<Sideset> Sideset::create(const std::shared_ptr<Communicator>          &comm,
                                             const std::shared_ptr<Buffer<element_idx_t>> &parent,
                                             const std::shared_ptr<Buffer<int16_t>>       &lfi,
                                             uint16_t                                      block_id) {
        return std::make_shared<Sideset>(comm, parent, lfi, block_id);
    }

    std::shared_ptr<Sideset> Sideset::create_from_file(const std::shared_ptr<Communicator> &comm,
                                                       const char                          *path,
                                                       uint16_t                             block_id) {
        auto ret = std::make_shared<Sideset>();
        if (ret->read(comm, path, block_id) != SFEM_SUCCESS) return nullptr;
        return ret;
    }

    int Sideset::write(const char *path) const {
        std::string sideset_path = path;
        sfem::create_directory(sideset_path.c_str());

        std::string parent_path = sideset_path + "/parent.raw";
        array_write(impl_->comm->get(),
                    parent_path.c_str(),
                    SFEM_MPI_ELEMENT_IDX_T,
                    impl_->parent->data(),
                    impl_->parent->size(),
                    impl_->parent->size());

        std::string lfi_path = sideset_path + "/lfi.int16.raw";
        array_write(impl_->comm->get(), lfi_path.c_str(), MPI_SHORT, impl_->lfi->data(), impl_->lfi->size(), impl_->lfi->size());

        std::ofstream os(sideset_path + "/meta.yaml");

        if (os.good()) {
            os << "# Automatically generated by sfem_Sideset.cpp\n";
            os << "parent: parent.raw\n";
            os << "lfi: lfi.int16.raw\n";
            os << "rpath: true\n";
        } else {
            SFEM_ERROR("Unable to open sideset meta.yaml file\n");
            return SFEM_FAILURE;
        }

        os.close();

        return SFEM_SUCCESS;
    }

    std::vector<std::shared_ptr<Sideset>> Sideset::create_from_selector(
            const std::shared_ptr<Mesh>                                         &mesh,
            const std::function<bool(const geom_t, const geom_t, const geom_t)> &selector,
            const std::vector<std::string>                                      &block_names) {
        SFEM_TRACE_SCOPE("Sideset::create_from_selector");

        // const ptrdiff_t nelements = mesh->n_elements();
        const ptrdiff_t nnodes = mesh->n_nodes();
        const int       dim    = mesh->spatial_dimension();

        auto points = mesh->points()->data();

        enum ElemType element_type = mesh->element_type();

        const enum ElemType st   = side_type(element_type);
        const int           nnxs = elem_num_nodes(st);
        const int           ns   = elem_num_sides(element_type);

        std::vector<int> local_side_table(ns * nnxs);
        fill_local_side_table(mesh->element_type(), local_side_table.data());

        size_t                                n_blocks = mesh->n_blocks();
        std::vector<std::shared_ptr<Sideset>> sidesets;

        for (size_t b = 0; b < n_blocks; b++) {
            auto block = mesh->block(b);
            if (!block_names.empty() &&  //
                std::find(block_names.begin(), block_names.end(), block->name()) == block_names.end()) {
                continue;
            }

            const ptrdiff_t nelements = block->n_elements();
            auto            elements  = block->elements()->data();

            std::list<element_idx_t> parent_list;
            std::list<int16_t>       lfi_list;
            for (ptrdiff_t e = 0; e < nelements; e++) {
                for (int s = 0; s < ns; s++) {
                    // Barycenter of face
                    double p[3] = {0, 0, 0};

                    for (int ln = 0; ln < nnxs; ln++) {
                        const idx_t node = elements[local_side_table[s * nnxs + ln]][e];

                        for (int d = 0; d < dim; d++) {
                            p[d] += points[d][node];
                        }
                    }

                    for (int d = 0; d < dim; d++) {
                        p[d] /= nnxs;
                    }

                    if (selector(p[0], p[1], p[2])) {
                        parent_list.push_back(e);
                        lfi_list.push_back(s);
                    }
                }
            }

            const ptrdiff_t nparents = parent_list.size();
            auto            parent   = create_host_buffer<element_idx_t>(nparents);
            auto            lfi      = create_host_buffer<int16_t>(nparents);

            {
                ptrdiff_t idx = 0;
                for (auto p : parent_list) {
                    parent->data()[idx++] = p;
                }
            }

            {
                ptrdiff_t idx = 0;
                for (auto l : lfi_list) {
                    lfi->data()[idx++] = l;
                }
            }

            sidesets.push_back(std::make_shared<Sideset>(mesh->comm(), parent, lfi, b));
        }

        return sidesets;
    }

    int Sideset::read(const std::shared_ptr<Communicator> &comm, const char *folder, uint16_t block_id) {
        SFEM_TRACE_SCOPE("Sideset::read");

        impl_->comm = comm;

        std::string    folder_ = folder;
        ptrdiff_t      nlocal{0}, nglobal{0}, ncheck{0};
        element_idx_t *parent{nullptr};
        int16_t       *lfi{nullptr};

        if (array_create_from_file(comm->get(),
                                   (folder_ + "/parent.raw").c_str(),
                                   SFEM_MPI_ELEMENT_IDX_T,
                                   (void **)&parent,
                                   &nlocal,
                                   &nglobal) ||
            array_create_from_file(
                    comm->get(), (folder_ + "/lfi.int16.raw").c_str(), MPI_SHORT, (void **)&lfi, &ncheck, &nglobal)) {
            return SFEM_FAILURE;
        }

        impl_->parent = sfem::manage_host_buffer(nlocal, parent);
        impl_->lfi    = sfem::manage_host_buffer(nlocal, lfi);

        if (ncheck != nlocal) {
            SFEM_ERROR("Inconsistent array sizes in sideset at %s\n", folder);
            return SFEM_FAILURE;
        }

        impl_->block_id = block_id;

        return SFEM_SUCCESS;
    }

    std::shared_ptr<Buffer<element_idx_t>> Sideset::parent() { return impl_->parent; }
    std::shared_ptr<Buffer<int16_t>>       Sideset::lfi() { return impl_->lfi; }
    uint16_t                               Sideset::block_id() const { return impl_->block_id; }

    std::shared_ptr<Buffer<idx_t>> create_nodeset_from_sidesets(const std::shared_ptr<FunctionSpace>        &space,
                                                                const std::vector<std::shared_ptr<Sideset>> &sidesets) {
        if (sidesets.empty()) {
            return nullptr;
        }

        if (sidesets.size() == 1) {
            return create_nodeset_from_sideset(space, sidesets[0]);
        }

        if (space->has_semi_structured_mesh()) {
            SFEM_ERROR("IMPLEMENT ME\n");
        } else {
            uint16_t                     n_sidesets = sidesets.size();
            std::vector<enum ElemType>   element_type(n_sidesets);
            std::vector<idx_t **>        elems(n_sidesets);
            std::vector<ptrdiff_t>       n_surf_elements(n_sidesets);
            std::vector<element_idx_t *> parent_element(n_sidesets);
            std::vector<int16_t *>       side_idx(n_sidesets);

            for (uint16_t k = 0; k < n_sidesets; k++) {
                auto ss              = sidesets[k];
                auto block           = space->mesh_ptr()->block(ss->block_id());

                element_type[k]    = block->element_type();
                elems[k]           = block->elements()->data();
                n_surf_elements[k] = ss->parent()->size();
                parent_element[k]  =  ss->parent()->data();
                side_idx[k]        = ss->lfi()->data();
            }

            ptrdiff_t n_nodes_out{0};
            idx_t   *nodes_out{nullptr};

            extract_nodeset_from_sidesets(n_sidesets,
                                          element_type.data(),
                                          elems.data(),
                                          n_surf_elements.data(),
                                          parent_element.data(),
                                          side_idx.data(),
                                          &n_nodes_out,
                                          &nodes_out);

            return sfem::manage_host_buffer(n_nodes_out, nodes_out);
        }
        return nullptr;
    }

    std::shared_ptr<Buffer<idx_t>> create_nodeset_from_sideset(const std::shared_ptr<FunctionSpace> &space,
                                                               const std::shared_ptr<Sideset>       &sideset) {
        ptrdiff_t n_nodes{0};
        idx_t    *nodes{nullptr};
        if (space->has_semi_structured_mesh()) {
            auto &&ss = space->semi_structured_mesh();
            SFEM_TRACE_SCOPE("sshex8_extract_nodeset_from_sideset");
            if (sshex8_extract_nodeset_from_sideset(ss.level(),
                                                    ss.element_data(),
                                                    sideset->parent()->size(),
                                                    sideset->parent()->data(),
                                                    sideset->lfi()->data(),
                                                    &n_nodes,
                                                    &nodes) != SFEM_SUCCESS) {
                SFEM_ERROR("Unable to extract nodeset from sideset!\n");
            }
        } else {
            if (extract_nodeset_from_sideset(space->element_type(),
                                             space->mesh_ptr()->elements()->data(),
                                             sideset->parent()->size(),
                                             sideset->parent()->data(),
                                             sideset->lfi()->data(),
                                             &n_nodes,
                                             &nodes) != SFEM_SUCCESS) {
                SFEM_ERROR("Unable to extract nodeset from sideset!\n");
            }
        }

        return sfem::manage_host_buffer(n_nodes, nodes);
    }

    std::pair<enum ElemType, std::shared_ptr<Buffer<idx_t *>>> create_surface_from_sideset(
            const std::shared_ptr<FunctionSpace> &space,
            const std::shared_ptr<Sideset>       &sideset) {
        if (space->has_semi_structured_mesh()) {
            auto &&ssmesh = space->semi_structured_mesh();
            auto   ss_sides =
                    sfem::create_host_buffer<idx_t>((ssmesh.level() + 1) * (ssmesh.level() + 1), sideset->parent()->size());

            if (sshex8_extract_surface_from_sideset(ssmesh.level(),
                                                    ssmesh.element_data(),
                                                    sideset->parent()->size(),
                                                    sideset->parent()->data(),
                                                    sideset->lfi()->data(),
                                                    ss_sides->data()) != SFEM_SUCCESS) {
                SFEM_ERROR("Unable to extract surface from sideset!\n");
            }

            idx_t           *idx          = nullptr;
            ptrdiff_t        n_contiguous = SFEM_PTRDIFF_INVALID;
            std::vector<int> levels(sshex8_hierarchical_n_levels(ssmesh.level()));

            // FiXME harcoded for sshex8
            sshex8_hierarchical_mesh_levels(ssmesh.level(), levels.size(), levels.data());

            const int nnxs    = 4;
            const int nexs    = ssmesh.level() * ssmesh.level();
            auto      surface = sfem::create_host_buffer<idx_t>(nnxs, sideset->parent()->size() * nexs);

            ssquad4_to_standard_quad4_mesh(ssmesh.level(), sideset->parent()->size(), ss_sides->data(), surface->data());
            return {QUADSHELL4, surface};
        } else {
            auto st   = shell_type(side_type(space->element_type()));
            int  nnxs = elem_num_nodes(st);

            auto surface = sfem::create_host_buffer<idx_t>(nnxs, sideset->parent()->size());
            auto mesh    = space->mesh_ptr();
            if (extract_surface_from_sideset(space->element_type(),
                                             mesh->elements()->data(),
                                             sideset->parent()->size(),
                                             sideset->parent()->data(),
                                             sideset->lfi()->data(),
                                             surface->data()) != SFEM_SUCCESS) {
                SFEM_ERROR("Unable to create surface from sideset!");
            }
            return {st, surface};
        }
    }

    std::pair<enum ElemType, std::shared_ptr<Buffer<idx_t *>>> create_surface_from_sidesets(
            const std::shared_ptr<FunctionSpace>        &space,
            const std::vector<std::shared_ptr<Sideset>> &sidesets) {
        if (sidesets.empty()) {
            return {INVALID, nullptr};
        }

        if (sidesets.size() == 1) {
            return create_surface_from_sideset(space, sidesets[0]);
        }

        SFEM_ERROR("IMPLEMENT ME\n");
        return {INVALID, nullptr};
    }
}  // namespace sfem
