#include "sfem_Sideset.hpp"

#include <stddef.h>

#include "matrixio_array.h"
#include "utils.h"

#include "sfem_defs.h"
#include "sfem_logger.h"
#include "sfem_mesh.h"
#include "sfem_Tracer.hpp"

#include <sys/stat.h>
#include <cstddef>
#include <fstream>
#include <iostream>
#include <list>
#include <vector>

// Mesh
#include "adj_table.h"
#include "hex8_fff.h"
#include "hex8_jacobian.h"
#include "sfem_hex8_mesh_graph.h"
#include "sshex8.h"
#include "sshex8_mesh.h"

// C++ includes
#include "sfem_glob.hpp"

namespace sfem {

    class Sideset::Impl final {
    public:
        std::shared_ptr<Communicator> comm;
        std::shared_ptr<Buffer<element_idx_t>> parent;
        std::shared_ptr<Buffer<int16_t>>       lfi;
    };

    Sideset::Sideset(const std::shared_ptr<Communicator>& comm,
                     const std::shared_ptr<Buffer<element_idx_t>> &parent,
                     const std::shared_ptr<Buffer<int16_t>>       &lfi)
        : impl_(std::make_unique<Impl>()) {
        impl_->comm   = comm;
        impl_->parent = parent;
        impl_->lfi    = lfi;
    }

    Sideset::Sideset() : impl_(std::make_unique<Impl>()) {}
    Sideset::~Sideset() = default;

    ptrdiff_t Sideset::size() const { return impl_->parent->size(); }

    std::shared_ptr<Communicator> Sideset::comm() const { return impl_->comm; }

    std::shared_ptr<Sideset> Sideset::create(const std::shared_ptr<Communicator>& comm,
                                             const std::shared_ptr<Buffer<element_idx_t>> &parent,
                                             const std::shared_ptr<Buffer<int16_t>>       &lfi) {
        return std::make_shared<Sideset>(comm, parent, lfi);
    }

    std::shared_ptr<Sideset> Sideset::create_from_file(const std::shared_ptr<Communicator>& comm, const char *path) {
        auto ret = std::make_shared<Sideset>();
        if (ret->read(comm, path) != SFEM_SUCCESS) return nullptr;
        return ret;
    }

    int Sideset::write(const char *path) const {
        std::string sideset_path = path;
        sfem::create_directory(sideset_path.c_str());

        std::string parent_path = sideset_path + "/parent.raw";
        array_write(impl_->comm->get(), parent_path.c_str(), SFEM_MPI_ELEMENT_IDX_T, impl_->parent->data(), impl_->parent->size(), impl_->parent->size());

        std::string lfi_path = sideset_path + "/lfi.int16.raw";
        array_write(impl_->comm->get(), lfi_path.c_str(), MPI_SHORT, impl_->lfi->data(), impl_->lfi->size(), impl_->lfi->size());

        std::ofstream os(sideset_path + "/meta.yaml");

        if (os.good()) {
            os << "# Automatically generated by sfem_Sideset.cpp\n";
            os << "parent: parent.raw\n";
            os << "lfi: lfi.int16.raw\n";
            os << "rpath: true\n";
        } else {
            SFEM_ERROR("Unable to open sideset meta.yaml file\n");
            return SFEM_FAILURE;
        }

        os.close();

        return SFEM_SUCCESS;
    }

    std::shared_ptr<Sideset> Sideset::create_from_selector(
            const std::shared_ptr<Mesh>                                         &mesh,
            const std::function<bool(const geom_t, const geom_t, const geom_t)> &selector) {
        SFEM_TRACE_SCOPE("Sideset::create_from_selector");

        const ptrdiff_t nelements = mesh->n_elements();
        const ptrdiff_t nnodes    = mesh->n_nodes();
        const int       dim       = mesh->spatial_dimension();

        auto elements = mesh->elements()->data();
        auto points   = mesh->points()->data();

        enum ElemType element_type = mesh->element_type();

        const enum ElemType st   = side_type(element_type);
        const int           nnxs = elem_num_nodes(st);
        const int           ns   = elem_num_sides(element_type);

        std::vector<int> local_side_table(ns * nnxs);
        fill_local_side_table(mesh->element_type(), local_side_table.data());

        std::list<element_idx_t> parent_list;
        std::list<int16_t>       lfi_list;

        for (ptrdiff_t e = 0; e < nelements; e++) {
            for (int s = 0; s < ns; s++) {
                // Barycenter of face
                double p[3] = {0, 0, 0};

                for (int ln = 0; ln < nnxs; ln++) {
                    const idx_t node = elements[local_side_table[s * nnxs + ln]][e];

                    for (int d = 0; d < dim; d++) {
                        p[d] += points[d][node];
                    }
                }

                for (int d = 0; d < dim; d++) {
                    p[d] /= nnxs;
                }

                if (selector(p[0], p[1], p[2])) {
                    parent_list.push_back(e);
                    lfi_list.push_back(s);
                }
            }
        }

        const ptrdiff_t nparents = parent_list.size();
        auto            parent   = create_host_buffer<element_idx_t>(nparents);
        auto            lfi      = create_host_buffer<int16_t>(nparents);

        {
            ptrdiff_t idx = 0;
            for (auto p : parent_list) {
                parent->data()[idx++] = p;
            }
        }

        {
            ptrdiff_t idx = 0;
            for (auto l : lfi_list) {
                lfi->data()[idx++] = l;
            }
        }

        return std::make_shared<Sideset>(mesh->comm(), parent, lfi);
    }

    int Sideset::read(const std::shared_ptr<Communicator>& comm, const char *folder) {
        SFEM_TRACE_SCOPE("Sideset::read");

        impl_->comm = comm;

        std::string    folder_ = folder;
        ptrdiff_t      nlocal{0}, nglobal{0}, ncheck{0};
        element_idx_t *parent{nullptr};
        int16_t       *lfi{nullptr};

        if (array_create_from_file(
                    comm->get(), (folder_ + "/parent.raw").c_str(), SFEM_MPI_ELEMENT_IDX_T, (void **)&parent, &nlocal, &nglobal) ||
            array_create_from_file(comm->get(), (folder_ + "/lfi.int16.raw").c_str(), MPI_SHORT, (void **)&lfi, &ncheck, &nglobal)) {
            return SFEM_FAILURE;
        }

        impl_->parent = sfem::manage_host_buffer(nlocal, parent);
        impl_->lfi    = sfem::manage_host_buffer(nlocal, lfi);

        if (ncheck != nlocal) {
            SFEM_ERROR("Inconsistent array sizes in sideset at %s\n", folder);
            return SFEM_FAILURE;
        }

        return SFEM_SUCCESS;
    }

    std::shared_ptr<Buffer<element_idx_t>> Sideset::parent() { return impl_->parent; }
    std::shared_ptr<Buffer<int16_t>>       Sideset::lfi() { return impl_->lfi; }

}  // namespace sfem 